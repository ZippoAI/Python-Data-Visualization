<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shader Lines</title>

</head>
<body>

  <section class="shader-demo-container">
    <div id="shader-container"></div>

    <h1 class="shader-title">
      GAYNAMO
    </h1>
  </section>

</body>
</html>

<style>

  * {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: #0a0a0a;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  color: #fff;
}

.shader-demo-container {
  position: relative;
  width: 100%;
  height: 1000px;
  overflow: hidden;
  border-radius: 20px;
  margin: 40px auto;
  max-width: 1400px;
}

#shader-container {
  position: absolute;
  inset: 0;
  z-index: 1;
}

.shader-title {
  position: relative;
  z-index: 2;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: clamp(3rem, 7vw, 6rem);
  font-weight: 700;
  letter-spacing: -0.04em;
  pointer-events: none;
  text-align: center;
}

</style>

<script>

  (function () {
  let animationId = null
  let renderer, scene, camera, uniforms

  function loadThreeJS(callback) {
    if (window.THREE) {
      callback()
      return
    }

    const script = document.createElement("script")
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/three.js/89/three.min.js"
    script.onload = callback
    document.head.appendChild(script)
  }

  function initShaderAnimation(container) {
    const THREE = window.THREE

    camera = new THREE.Camera()
    camera.position.z = 1

    scene = new THREE.Scene()

    const geometry = new THREE.PlaneBufferGeometry(2, 2)

    uniforms = {
      time: { value: 1.0 },
      resolution: { value: new THREE.Vector2() },
    }

    const vertexShader = `
      void main() {
        gl_Position = vec4(position, 1.0);
      }
    `

    const fragmentShader = `
      #define TWO_PI 6.2831853072
      precision highp float;

      uniform vec2 resolution;
      uniform float time;

      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }

      void main() {
        vec2 uv = (gl_FragCoord.xy * 2.0 - resolution.xy) 
                  / min(resolution.x, resolution.y);

        vec2 scale = vec2(4.0, 2.0);
        uv = floor(uv * 256.0 / scale) / (256.0 / scale);

        float t = time * 0.06 + random(vec2(uv.x)) * 0.4;
        float lw = 0.0008;

        vec3 col = vec3(0.0);

        for (int j = 0; j < 3; j++) {
          for (int i = 0; i < 5; i++) {
            col[j] += lw * float(i * i) /
              abs(fract(t - 0.01 * float(j) + float(i) * 0.01)
              - length(uv));
          }
        }

        gl_FragColor = vec4(col.b, col.g, col.r, 1.0);
      }
    `

    const material = new THREE.ShaderMaterial({
      uniforms,
      vertexShader,
      fragmentShader,
    })

    const mesh = new THREE.Mesh(geometry, material)
    scene.add(mesh)

    renderer = new THREE.WebGLRenderer({ antialias: true })
    renderer.setPixelRatio(window.devicePixelRatio)
    container.appendChild(renderer.domElement)

    function resize() {
      const rect = container.getBoundingClientRect()
      renderer.setSize(rect.width, rect.height)
      uniforms.resolution.value.set(
        renderer.domElement.width,
        renderer.domElement.height
      )
    }

    window.addEventListener("resize", resize)
    resize()

    function animate() {
      animationId = requestAnimationFrame(animate)
      uniforms.time.value += 0.05
      renderer.render(scene, camera)
    }

    animate()
  }

  document.addEventListener("DOMContentLoaded", () => {
    const container = document.getElementById("shader-container")
    if (!container) return

    loadThreeJS(() => initShaderAnimation(container))
  })

  window.addEventListener("beforeunload", () => {
    if (animationId) cancelAnimationFrame(animationId)
    if (renderer) renderer.dispose()
  })
})()

</script>